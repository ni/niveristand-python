from enum import Enum
import time
from niveristand import _errormessages
from niveristand import _internal
from niveristand.errors import SequenceError, VeristandError
from NationalInstruments.VeriStand.Data import DataType  # noqa: E501, I100 We need these C# imports to be out of order.

_internal.dummy()


class StimulusProfileState(object):
    """Contains the execution state of a real-time sequence."""

    class CompletionState(Enum):
        """Enum used for possible completion states."""

        Success = 0  #: operation ran to completion successfully. No errors occurred.
        Aborted = 1  #: operation stopped forcefully.
        Failed = 2  #: operation ran to completion, but an error occurred.

    def __init__(self, session):
        self._ret_val = None
        self._rt_sequence_completed = False
        self._completion_state = None
        self._session = session
        self._last_error = None

    @property
    def last_error(self):
        """
        Returns the last error generated by the sequence.

        Returns:
            :class:`niveristand.errors.SequenceError`: final error the sequence generated.

        """
        return self._last_error

    @property
    def ret_val(self):
        """
        Returns the return value of the sequence.

        Returns:
            (bool, int, float): the return value of the sequence.

        """
        return self._ret_val

    @property
    def completion_state(self):
        """
        Returns the state after running.

        Returns:
            :class:`CompletionState`: state after the operation runs to completion. `None` if unfinished.

        """
        return self._completion_state

    @property
    def session(self):
        """
        Returns the session you created to execute this sequence.

        Returns:
            a session connected to the VeriStand Engine.

        """
        return self._session

    def _sequence_complete_event_handler(self, source, args):
        from niveristand.clientapi import ErrorAction
        data_value = args.ReturnValue
        if data_value.Type == DataType.Void:
            self._ret_val = None
        elif data_value.Type in [DataType.Boolean, DataType.Double, DataType.Int32, DataType.Int64, DataType.UInt32,
                                 DataType.UInt64]:
            self._ret_val = data_value.Value
        else:
            raise VeristandError(_errormessages.invalid_return_type)
        aborted = args.Aborted
        error = args.Error
        if aborted:
            self._completion_state = StimulusProfileState.CompletionState.Aborted
            self._last_error = SequenceError(error.Code, error.Message, ErrorAction.AbortSequence)
        else:
            if error.Code != 0:
                self._completion_state = StimulusProfileState.CompletionState.Failed
                self._last_error = SequenceError(error.Code, error.Message, ErrorAction.ContinueSequenceExecution)
            else:
                self._completion_state = StimulusProfileState.CompletionState.Success
        self._rt_sequence_completed = True

    def wait_for_result(self):
        """
        Waits for the sequence to finish running.

        Returns:
            the value returned by the VeriStand Engine after this sequence runs.

        """
        while not self._rt_sequence_completed:
            time.sleep(0.01)
        return self._ret_val
